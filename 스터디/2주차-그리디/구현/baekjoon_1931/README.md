# 1931번 회의실 배정

## 문제
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.


## 입력
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

## 출력
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

## 예제 입력
```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

## 예제 출력
```
4
```

## 코드
```
#회의실 배정
import sys
from sys import stdin
k=int(stdin.readline())
meeting=[]
for _ in range(k):
    meeting.append(list(map(int,input().split())))       #이차원 배열으로 회의 시간 입력 받기
meeting.sort()     #0번 인덱스 기준으로 정렬하기
meeting.sort(key = lambda x: x[1])       #1번 인덱스 기준으로 정렬하기

sum = 1 
conference = meeting[0][1] #첫번째 회의가 끝나는 시간 저장하기
for i in range(1, k): 
    if meeting[i][0] >= conference :  #다음 회의가 시작하는 시간이 이전 회의가 끝나는 시간보다 크거나 같은 경우 실행
        sum += 1 
        conference  = meeting[i][1] #변수의 값 바꿔주기
print(sum)
```


### CodeReview
값을 변수에 저장하고 만약 그 변수가 내가 찾는 값과 비교해서 조건에 맞으면
변수에 다른 값을 저장시키는 아이디어를 떠올리기 힘들어 어렵게 느껴졌던 문제다.
또한 0번 인덱스 기준으로 정렬하고 난 뒤 1번 인덱스 기준으로 다시 정렬 해줘야
하는 것도 까다로웠다.
