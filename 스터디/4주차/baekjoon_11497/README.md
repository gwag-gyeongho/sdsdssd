# 11497번 통나무 건너뛰기

## 문제
남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다.



통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다.

## 입력
입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.

이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000)

## 출력
각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.

## 예제 입력
```
3
7
13 10 12 11 10 11 12
5
2 4 5 7 9
8
6 6 6 6 6 6 6 6
```

## 예제 출력
```
1
4
0
```

## 코드
```
#통나무 건너뛰기
import sys
from sys import stdin
#테스트 케이스 횟수 입력받기
t=int(stdin.readline())
#t번만큼 반복하기
for _ in range(t):
    n = int(stdin.readline())
    #리스트 형태로 입력받기
    log =list(map(int, stdin.readline().split()))
    #오름차순으로 정렬하기
    log.sort()
    a = []
    #가장 작은 값이 중간에 오도록 리스트 다시 만들기
    for i in range(n):
        if i%2==0:
            a.insert(0,log[i])
        elif i%2==1:
            a.insert(len(a),log[i])

    cnt=[]
    #리스트의 양 옆 인덱스마다 차를 구해서 절댓값이 가장 큰 수 출력하기
    for i in range(n-1):
        cnt.append(abs(a[i]-a[i+1]))
    print(int(max(cnt)))


```

   
   
   
   
   
###  CodeReview 
리스트를 입력받아 오름차순으로 정렬 한 뒤에 그 리스트를 가장 작은 값을 기준으로 양옆으로 하나하나 씩 재배치 하는게 핵심인 문제였다. 그 후에는 한 인덱수와 다음 인덱스와의 차의 절댓값을 구해서 그 수를 각각 리스트에 다시 넣은 다음 그 리스트 중에 최댓값을 출력하면 답이 된다. 최솟값을 기준으로 양 옆에 오름차순으로 양 옆에 번갈아가면서 배치 한다는 아이디어를 떠올리는것과 그 것을 어떻게 구현할지가 어려웠던 문제였다.
   
